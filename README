Sheeple is a CLOS-like prototype-based object-oriented system for ANSI Common Lisp. This
implementation is canonical and is currently implemented only for SBCL.

Vocabulary:

*Sheep - singular used to refer to a single Sheeple object.

*Sheeple - plural used to refer to more than one sheep. Also used to refer to the project.

*Hierarchy List - An acyclic graph generated by COMPUTE-SHEEP-HIERARCHY-LIST that contains the
calculated ancestors of a particular sheep, sorted breadth-first left-right.

*Ancestor - Any sheep that appears in the list generated by COMPUTE-SHEEP-HIERARCHY-LIST for any
given sheep. This list only includes direct ancestors, not objects that could be considered
'cousins'.

*Descendant - For a sheep X, any sheep whose hierarchy list will contain X.

*Parent - A direct parent of a sheep, e.g. a sheep object present directly in a sheeps
sheep-direct-parents list.

*Child - A direct child of a sheep.


Specification:

== Object Creation ==

* Objects are prototypes. Objects are called sheep or sheeple. All sheep are children of DOLLY.

* Sheep can have multiple direct parents (multiple inheritance)

* Ancestor ordering works the same way as it does with CLOS (first parent defined in CLONE has
  greater precedence than second.) Ancestors are ordered with a breadth-first left-to-right graph
  sorting algorithm.

* All objects have a numerical SID (Sheep ID)

* The list of direct parents is dynamic. Parents can be added or removed at runtime.

* Sheeple does not have a universal addressing mechanism like functions and classes do. Instead,
there are a number of built-in sheeple, including DOLLY, which can be addressed by symbol where
useful, such as when setting one of them as a parent, or defining a talent.

* Built-in sheeple correspond to all built-in Lisp types, as well as any new types defined by
  DEFTYPE, but not to CLOS-defined classes.

* New sheeple are created by using the CLONE macro. CLONE works similar to DEFCLASS:

(clone (parent1 parent2)
  ((slot1 value1)
   (slot2 value2)))

(clone ()) ;; also valid. Slot spec is optional.

(clone () ((foo 10)))

(defvar *sample-sheep* (clone ()))

* An empty parent list when using CLONE will automatically clone DOLLY

* The function ADD-PARENT receives a NEW-PARENT sheep, and a CHILD sheep. It pushes NEW-PARENT into
CHILD's direct-parents if NEW-PARENT is not already there. If using ADD-PARENT would result in a
cyclic hierarchy list, a SHEEP-HIERARCHY-ERROR condition is signaled, and the CHILD is unaffected.
-- ex: (add-parent *mommy* *kiddo*) => <SHEEP SID: 2> (*kiddo*)
       (add-parent *kiddo's-descendant* *kiddo*) => ERROR: SHEEP-HIERARHY-ERROR

* The function REMOVE-PARENT receives a PARENT sheep and a CHILD sheep. It also takes an optional
:keep-properties value that can be T or NIL. If T, it will copy all of PARENT's direct-properties
into CHILD before removing the parent from the child's direct-parents. If NIL, the parent's
direct-properties will no longer apply to child.
-- ex: (remove-parent *daddy* *kiddo*) => KIDDO object, without *daddy*'s direct-slot values.
       (remove-parent *daddy* *kiddo* :keep-properties t) => KIDDO object, with a copy of *daddy*'s
       direct-slots.

== Property Values ==

* Properties are key-value pairs, where key is a symbol.

* One property may only have one value, although that value can be a collection of some sort.

* Sheeple have direct properties and indirect properties

* Direct properties are set directly in a specific sheep object.

* Indirect properties are accessed by searching for direct properties that have been set along the
sheep's inheritance chain. The value of that ancestor's property is used instead.

* Changing the value in the parent thus changes the value in the child.

* A child may override the value set by one of its parents at any time by setting a direct property.

* If an ancestor already sets a property, a descendant may not remove that property from itself,
  unless it removes that property from the ancestor.

* When accessing indirect properties, the hierarchy list ordering is obeyed.

* The function GET-PROPERTY receives two arguments: a sheep object and a property-name. It returns
  the value of that property, and searches indirect properties. There is no user-level function for
  only getting the direct property value of a sheep. Signals a condition of type UNBOUND-PROPERTY if
  there is no binding, direct or indirect, for that property-name.
  -- ex: (get-property *sample-sheep* 'foo)

* The function (SETF GET-PROPERTY) sets a direct property on a sheep. If the property did not exist,
  it adds it, and it changes it if it did.
  -- ex: (setf (get-property *sample-sheep* 'foo) 'bar)

* The function HAS-DIRECT-PROPERTY-P returns T if a direct property was set on sheep, and NIL
  otherwise.
  -- ex: (has-direct-property-p *sample-sheep* 'foo) => T

* The function REMOVE-PROPERTY receives a sheep and a property-name, and removes a direct property
  from sheep. Returns NIL if there was no direct property with that property-name set, and T if it
  removed an existing property.
  -- ex: (remove-property *sample-sheep* 'foo) => T

* The function WHO-SETS receives a SHEEP and a PROPERTY-NAME, and returns the sheep that sets a
  particular property visible to SHEEP, whether it be a direct-property or an indirect-property.
  If the property is unbound, it simply returns NIL.
  -- ex: (who-sets *sample-sheep* 'foo) => NIL

* The function AVAILABLE-PROPERTIES receives a SHEEP, and returns a list of available bound
  property keys for SHEEP.
  -- ex: (setf (get-property *sample-sheep* 'baz) 'quux)
     	 (available-properties *sample-sheep*) ==> (BAZ)

== Talents ==

