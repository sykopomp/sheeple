About
-----

Sheeple is a Dynamic, CLOS-like Prototype-based Object-Oriented Programming Framework that strives
to maximize application flexibility, minimize cost while maximizing value, optimize programmer time,
and empower application implementers to better assist them leveraging modern paradigms in
order to proactively achieve next-gen synergy in tomorrow's web 3.0 world. It is implemented in ANSI
Common Lisp, with small parts are based on Closette. Sheeple is fully buzzword compliant.

Notes
-----

Sheeple should work on just about every implementation out there with a working CLOS
implementation. It is developed and tested on SBCL, but tests on other implementations would be
greatly appreciated. 

At the moment, Sheeple performance makes Ruby feel like optimized assembly, so it might not be
appropriate for large applications. It's quite fun to play around with. Once it has all features
working and passes all unit tests, there's plenty of fairly easy optimization to do, and it should
run more acceptably.

Features available so far:

* Simple defclass-like cloning interface

* Dynamic object management tools (inspection of objects, addition/removal of slots, all without any
  sort of redefinition)

* Dynamic definition of slot values, following a prototype chain

* Full integration with built-in Lisp types by autoboxing (called fleecing) when appropriate

* Multiple inheritance through cloning with dynamic inspection and management of parents

* Multiple dispatch on messages (methods) -- messages specialize on specific instances, and follow
  inheritance hierarchy. Algorithm is based on Slate (http://slatelanguage.org)

* Multimessages work similarly to CLOS methods -- you define a generic function (defbuzzword), and a
  set of methods (defmessage), which can optionally have specialized arguments.

* defbuzzword/defmessage have basically the same interface as defgeneric/defmessage.

* Portable across implementations -- no MOP or fancy features required

* CLOS backend allows effortless plug-in to many Lisp libraries that make use of the MOP (such as
  Elephant, for almost free object persistence)

* Runs on plain CL -- no libraries necessary

* Slow as all hell -- gives you more time to think about what you're doing.


Features that have not been implemented yet include:

* :before, :after, and :around messages

* Property options and Sheep options, all through the CLONE macro

* Related to the above -- auto-generated accessors/readers/writers

* Also related to above -- advanced cloning options

* A proper MOP

* CLOS integration, including autoboxing of entire class hierarchies

* Dynamic removal of messages, and entire buzzwords


Vocabulary
----------

* Sheep - singular used to refer to a single Sheeple object.

* Sheeple - plural used to refer to more than one sheep. Also used to refer to the project.

* Hierarchy List - An acyclic graph generated by COMPUTE-SHEEP-HIERARCHY-LIST that contains the
calculated ancestors of a particular sheep, sorted breadth-first left-right.

* Ancestor - Any sheep that appears in the list generated by COMPUTE-SHEEP-HIERARCHY-LIST for any
given sheep, with sheep removed. This list only includes direct ancestors, not objects that could be
considered 'cousins'.

* Descendant - For a sheep X, any sheep Y whose hierarchy list will contain X, except Y itself.

* Parent - A direct parent of a sheep, e.g. a sheep object present directly in a sheep's
sheep-direct-parents list.

* Child - A direct child of a sheep.

* Buzzword - A Generic function. Holds pointers to all existing messages (methods)

* Message - The message a particular buzzword gets across when given a set of arguments. Messages
  are defines for a specific set of args, and can be specialized on particular sheeple. Built-in
  types are supported, with the naming scheme =type-name=.

* Wolf - A built-in lisp type

* Fleece - A wrapper for wolves that allows Sheeple to treat them as any other sheep -- specializing
methods, cloning, etc.

* Fleeced wolf - A wolf wrapped in a fleece. e.g. an autoboxed built-in type

Specification:
--------------
== Sheep Cloning ==

* Objects are prototypes. Objects are called sheep or sheeple. All sheep are children of =DOLLY=.

* Sheep can have multiple direct parents (multiple inheritance)

* Ancestor ordering works the same way as it does with CLOS (first parent defined in CLONE has
  greater precedence than second.) Ancestors are ordered with a breadth-first left-to-right graph
  sorting algorithm.

* All objects have a numerical SID (Sheep ID)

* The list of direct parents is dynamic. Parents can be added or removed at runtime.

* Sheeple does not have a universal addressing mechanism like functions and classes do. Instead,
there are a number of built-in sheeple, including =DOLLY=, which can be addressed by symbol where
useful, such as when setting one of them as a parent, or defining a talent.

* Built-in sheeple correspond to all built-in Lisp types, as well as any new types defined by
  DEFTYPE, but not to CLOS-defined classes.

* New sheeple are created by using the CLONE macro. CLONE works similar to DEFCLASS:

         (clone (parent1 parent2)
           ((slot1 value1)
            (slot2 value2)))

         (clone ()) ;; also valid. Slot spec is optional.

         (clone () ((foo 10)))

         (defvar *sample-sheep* (clone ()))

* An empty parent list when using CLONE will automatically clone =DOLLY=

* The function ADD-PARENT receives a NEW-PARENT sheep, and a CHILD sheep. It pushes NEW-PARENT into
CHILD's direct-parents if NEW-PARENT is not already there. If using ADD-PARENT would result in a
cyclic hierarchy list, a SHEEP-HIERARCHY-ERROR condition is signaled, and the CHILD is
unaffected. The new-parent is added to the front of the direct-parents list, like a stack
push. Returns the CHILD object.

        (add-parent *mommy* *kiddo*) => <SHEEP SID: 2> (*kiddo*)
        (add-parent *kiddo's-descendant* *kiddo*) => ERROR: SHEEP-HIERARHY-ERROR


* The function REMOVE-PARENT receives a PARENT sheep and a CHILD sheep. It also takes an optional
:keep-properties value that can be T or NIL. If T, it will copy all of PARENT's direct-properties
into CHILD before removing the parent from the child's direct-parents. If NIL, the parent's
direct-properties will no longer apply to child. Returns the CHILD object.
        
        (remove-parent *daddy* *kiddo*) 
        => KIDDO object, without *daddy*'s direct-slot values.
       
        (remove-parent *daddy* *kiddo* :keep-properties t) 
        => KIDDO object, with a copy of *daddy*'s direct-slots.

* The functions DIRECT-PARENT-P, ANCESTOR-P, DIRECT-CHILD-P, and DESCENDANT-P return T for their
corresponding checks.


== Property Values ==

* Properties are key-value pairs, where key is a symbol.

* One property may only have one value, although that value can be a collection of some sort.

* Sheeple have direct properties and indirect properties

* Direct properties are set directly in a specific sheep object.

* Indirect properties are accessed by searching for direct properties that have been set along the
sheep's inheritance chain. The value of that ancestor's property is used instead.

* Changing the value in the parent thus changes the value in the child.

* A child may override the value set by one of its parents at any time by setting a direct property.

* If an ancestor already sets a property, a descendant may not remove that property from itself,
  unless it removes that property from the ancestor.

* When accessing indirect properties, the hierarchy list ordering is obeyed.

* The function GET-PROPERTY receives two arguments: a sheep object and a property-name. It returns
  the value of that property, and searches indirect properties. There is no user-level function for
  only getting the direct property value of a sheep. Signals a condition of type UNBOUND-PROPERTY if
  there is no binding, direct or indirect, for that property-name.

        (get-property *sample-sheep* 'foo)


* The function (SETF GET-PROPERTY) sets a direct property on a sheep. If the property did not exist,
  it adds it, and it changes it if it did. Returns the new value.

        (setf (get-property *sample-sheep* 'foo) 'bar)


* The function HAS-DIRECT-PROPERTY-P returns T if a direct property was set on sheep, and NIL
  otherwise.

        (has-direct-property-p *sample-sheep* 'foo) => T


* The function HAS-PROPERTY-P returns T if the property is available to sheep, whether it's direct
  or indirect.

        (has-property-p *sample-sheep* 'foo) => T


* The function REMOVE-PROPERTY receives a sheep and a property-name, and removes a direct property
  from sheep. Returns NIL if there was no direct property with that property-name set, and T if it
  removed an existing property.

        (remove-property *sample-sheep* 'foo) => T


* The function WHO-SETS receives a SHEEP and a PROPERTY-NAME, and returns the sheep that sets a
  particular property visible to SHEEP, whether it be a direct-property or an indirect-property.
  If the property is unbound, it simply returns NIL.

        (who-sets *sample-sheep* 'foo) => NIL


* The function AVAILABLE-PROPERTIES receives a SHEEP, and returns a list of available bound
  property keys for SHEEP. An empty list is returned if SHEEP has no available bound properties.

        (setf (get-property *sample-sheep* 'baz) 'quux)
        (available-properties *sample-sheep*) ==> (BAZ)


== Buzzwords ==

TODO - Refer to src/packages.lisp for a peek at the interface
