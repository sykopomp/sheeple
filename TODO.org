* TODO 1.1+
** TODO Implement :message option for defbuzzword (like CLOS' :method option)
   I don't care about this feature all that much, so I might just keep bumping it until someone
   who -does- care asks for it.
** TODO Allow individual message documentation
** TODO Make singly-dispatched readers just about as fast as simply calling property-value
** TODO Write caching scheme for property access.
   I should've done this in the first place. A simpler version of the same system used to dispatch
   messages would do wonders for read performance, without seriously harming writer performance.
* TODO 1.0
** TODO Complete documentation with tutorial and user's guide
** TODO Write more unit tests.
*** TODO Write unit tests for defsheep 
*** TODO Write unit tests for new LL stuff
*** DONE Write more thorough tests to make sure caching schemes aren't broken
    Honestly? The existing tests check this well enough.
*** TODO Write a "many many messages" test
*** TODO Write more tests with multi-level hierarchy lists
** TODO Fix any bugs unit tests come up with
*** TODO Oops -- CLONE should check that defining an accessor first, then passing it NIL is also an error
** TODO Write a small sample application (maybe convert yashmup?)
** TODO Finalize API
   No (significant) changes allowed to API until 2.0, after this release.
*** DONE Do I want to make CLONE work more like defclass*?
    That might be good. It would not be incompatible with older versions of Sheeple, either.
*** DONE Deprecate :manipulator?
    I should deprecate :manipulator in favor of :accessor, since with-accessors will work on both
    CLOS and Sheeple. :accessor is much nicer... I'll remain compatible for now.

*** DONE Go through src/packages.lisp and figure out how much I actually need right now.
*** DONE Should I shut off access to stuff like undefbuzzword/undefmessage?
    Not for now, but I should discourage use of it until I've figured it out.
*** TODO Finalize everything when all else is done.
* DONE 0.9
** DONE More optimization
   The goal here is to have manipulator dispatch be at a maximum 2x slower than property-value. If I
   can get it as fast as direct property-access, even better, but this shit can go so much faster
   without too much magic.
   Update: currently down to just under 10x slower for single dispatch vs direct property access
   Update: make that 5x slower. ;)
   Update: Sped up (setf property-value) a bit. I'm going to have to make a decision about what
   needs to be faster here -- perhaps I'll find out once I write some apps.
   Update: Caching property-owners was silly, and became incredibly expensive
   Update: Will stop optimizing after manipulators are optimized to an acceptable speed.
   Update: 5x really isn't that bad. I'm going to keep it for now.
** DONE Convert CHANGELOG to .org
** DONE Redefining buzzwords
   It would be really nice if buzzword-redefinition followed the same rules as CLOS
   Update: Good enough for now. It warns about shit.
* DONE 0.8
** DONE Optimize the shit out of message dispatch
   It's pretty fast right now, but nothing compared to PCL.
   I should read through the Slate paper again and see if I can implement any of their
   suggested optimizations.
   Additionally, I found a paper that talks about how PCL's caching works. I think I can
   implement something similar in sheeple, which would then make message dispatch absurdly fast.
   One word: MEMOIZATION. Do it.
   Memoization done, but profiling shows that there's other stuff in the way (such as the
   numerous calls to remove-if-not -during- dispatch time. Shit.
   As far as this remove-if-not, etc stuff goes -- I think I can figure out some fancy
   message-list caching system. The problem is that make-message-lambda might get confused, and
   I want to avoid changing stuff outside of message-dispatch.lisp as much as possible.
   There will be a time in the future when heavy-optimization and code-uglying will be appropriate.
   But for now, while the system is still being designed, it's best to keep things clean and
   flexible (and slow...).
   UPDATE: New caching system has made shit run hella-fast. According to sb-sprof, the next step
   would be to have a nicer hashing scheme, since using a list and using equal to fetch stuff from
   a hash table isn't really very speedy. For now, though, this will do! :) (haven't really tested
   this too much, though. Hm.)
** DONE Fix lambda-list keyword things
* DONE 0.7
** DONE Make initialize-instance a buzzword so :after messages can be defined
   both initialize-instance and reinitialize-instance are regular buzzwords now.
** DONE Have buzzwords accept &keywords in lambda lists, and maintain congruence as per CLOS
   This seemed to be working, but I have to put &allow-other-keys in all methods in order for it
   to work, which is sub-optimal. This can be fixed, and I should do it by 0.8
   UPDATE: Fix'd in make-message-lambda :)
* DONE 0.6
** DONE Write a replace-sheep function
  it should swap a sheep's properties/contents with a new 'definition',
  while maintaining identity.
** DONE Wrap replace-sheep with a DEFSHEEP macro.
** DONE Optimize the shit out of property-access
  Done for now -- it's only slightly slower than PCL right now
** DONE Work out the whole conditions thing, and what they print out. 
   Put them all in conditions.lisp?
* DONE 0.5
** DONE Get all pre-0.6 done by 0.5
