* TODO Later
** TODO Documentation
*** TODO [#A] Go through the whole thing and make it more CLHS-like (only partially done)
    The entire basic API for Sheeple should be correctly documented.
*** TODO [#C] Put together html and pdf versions of user-guide.org
** TODO Messages/Replies
*** TODO [#A] Write unit tests for messages and replies
    This really goes hand-in-hand with the heading below, but I'm refraining
    from deleting this heading just because of how important it is.
*** TODO [#B] Standard Reply Combination
    The Standard Method Combination of CLOS is the one
    with :around, :after, :before, and "primary" replies.  It would be good to
    get Sheeple's standard reply combination to behave in the same way as this.
**** DONE Remove CALL-NEXT-REPLY from :before and :after replies
**** DONE Enable nesting of :around replies
**** TODO Ensure proper order of replies:
     Most specific :around
      ...
       Least specific :around
        Most specific :before
        ...                      ; Return values ignored
        Least specific :before
        Most specific "primary"
         ...                     ; Return values go to :around
          Least specific "primary"
        Least specific :after
        ...                      ; Return values ignored
        Most specific :after

*** TODO [#B] Clean up sources
    These files are all pretty messy, and might have some low hacks that could
    be re-hacked in a more elegant way.
**** TODO messages.lisp
**** TODO reply-definition.lisp
**** TODO reply-dispatch.lisp
*** TODO [#C] Flexible Reply Combinations
***** TODO CLOS Built-In Method Combinations
      Each of these method combinations accepts 2 types of methods: "primary"
      methods and :around methods.  The :around methods are called like the
      standard combination.  "Primary" methods are qualified with the name of
      the combination, and are called in most-specific-first order.  Their
      return values are collected and passed to the function named in the method
      combination.
****** TODO PROGN, OR, AND
       Control structure combinations. Note that the OR and AND combinations are
       not short-circuiting like the macros of the same name -- they could more
       appropriately (and maybe should, in Sheeple's version) be called EVERY
       and SOME combinations.
****** TODO LIST, APPEND, NCONC
       Collection combinations. Useful for messages that need to build up
       data. I can imagine these also being useful for extending the behavior of
       some accessors.
****** TODO MAX, MIN, +
       Computation combinations. I'd say that these are least important, because
       they can be easily fudged using the LIST combination -- just wrap with
       an :around reply, all specializers on =T=, and #'APPLY the right function.
***** TODO DEFINE-REPLY-COMBINATION
      Under CLOS, it's possible to define a completely customized method
      combination.  Even though this is not frequently used, Sheeple should
      provide a similar feature.
** TODO Dynamicity
*** TODO [#A] Better error handling
    I should go over the entirety of sheeple and start filling the thing with
    restarts.  If this is going to be usably dynamic, it needs to have proper
    reporting of crummy conditions, and a nice way of recovering from them.
*** TODO [#B] Inconsistent lambda lists
    Adlai pointed out how CLOS offers a restart when lambda-lists are inconsistent,
    offering to remove inconsistent methods.  It's useful for interactively working.
    Could I support something like this in sheeple?
*** TODO [#C] Dynamic message and reply handling
   Under CLOS, it's possible to dynamically mess with replies.  Sheeple is
   currently not as flexible in this regard.  Basically, we should provide for
   messagen and replies all the stuff in AMOP for generic functions and methods.
** TODO Integration
*** TODO With Lisp
    The backtraces are awful. Good god.
*** TODO With SLIME
    It would be nice if SLIME had better support for highlighting and indentation
    of Sheeple forms, and if it had facilities for inspecting sheeple objects.
    Being able to do M-. and stuff would also be a HUGE plus.
** TODO Other features
*** TODO Property MOP
**** TODO Local Property Creation
     Let the user control what happens when a property is created locally
     through #'(setf property-value). This could be done with the same
     *-using-metaobject interface that we've used for the MOP code this far.
**** TODO Accessor Creation
     Let the user control how accessors are created for properties. A possible
     use of such a MOP feature could be a wrapper for mapping properties, such
     as the "channel-local" properties used in Sykobot, where accessors would
     take an additional argument used as a key in the mapping.
*** TODO Messages/replies
*** TODO Implement :message option for defmessage (like CLOS' :method option)
   I don't care about this feature all that much, so I might just keep bumping it until someone
   who -does- care asks for it.
   UPDATE: I don't think I even want this. It makes the defmessage macro horribly bloated and
   complex, and I don't even like the idea of stuffing everything into a message definition. Things
   need to stay flexible, and this would be just plain ugly.
** TODO Optimization
*** TODO Speed up accessors
   Accessors need to be fast. Really fast. Find ways to cheat that won't break everything.
*** TODO Speed up instantiation
    Since sheep are sheep now, we have to be fanatical "tree pruners" when it
    comes to optimizing any further. If we find that std-sheep are still too
    kludgy, find some way to reduce that kludge!
*** TODO Consider caching scheme for property access
    I should've done this in the first place. A simpler version of the same
    system used to dispatch replies would do wonders for read performance,
    without seriously harming writer performance.
* TODO 3.1
** TODO Metasheep Protocol
*** TODO Property MOP
*** TODO Extend sheep-creation MOP
*** TODO Begin work on message/reply MOP (maybe)
* TODO 3.0
  This is a rough sketch of The Road to Sheeple 3.0
** TODO [#A] "Test all the fucking time."
   This is very important. Watch the entire thing, twice.
   http://rubyhoedown2008.confreaks.com/05-bryan-liles-lightning-talk-tatft-test-all-the-f-in-time.html
   Then watch this:
   http://www.vimeo.com/1534976?pg=embed&sec=1534976
   Then go write some tests, and test all the fucking time.
*** TODO %enlarge-child-cache
**** TODO Check that entries are moved over
**** TODO Check that errors are signalled if there is no child cache
*** TODO Improve tests for printing
    This might require CL-PPCRE.  Also, there should be better tests for the
    initialization of various *print-foobar* settings.
*** TODO Improve test for WITH-SHEEP-HIERARCHY
    It's too brittle right now -- the entire thing fails if something is wrong
    in the implementation. Make the tests more modular.
*** TODO Convert tests to use WITH-SHEEP-HIERARCHY
    We might as well use this macro, since it's so compact.
*** TODO Update tests for FIND-MESSAGE vs %FIND-MESSAGE
*** TODO Do #'std-c-s-h-l and #'c-s-h-l need separate tests?
** DONE [#B] Fix Sheep Allocation
   We need std-allocate-sheep, along with a MOP hook so that, for
   example, you could allocate storage in a database in an :after reply.
** TODO Instantiation
   It could use some work. The defproto/defsheep/spawn triumverate needs a cleanup. Particularly,
   it would be nice to merge spawn/defsheep into a simpler function/macro. Maybe it should just be
   defsheep, in the end.
** TODO Properties
*** DONE Reimplement properties
    Write a basic reimplementation of sheep properties.
*** DONE TATFT
*** TODO Improve the whole add-property interface.
    This is partly done right now... add-property itself has been greatly simplified.
    I think what needs to be done now is that a macro should be written to take care
    of all the fancy features that add-property used to handle. Perhaps write a
    defproperty macro?
** TODO Messages, Replies
   Update code so that these work again.
** TODO "Sanely Bootstrappable"
   Let's not go insane between now and when (test bootstrapped?) passes.
*** TODO Write proper print functions
    It makes sense to me (Adlai) to do all printing through the pretty-printer
    right now -- that way, we have a quick hook to examine raw sheep without
    messing around with #'print-object.  This is basically how it should look:
**** TODO #'print-young-sheep with lowest priority
     Specialized on type 'sheep, this function should print sheep that have
     absolutely no info about them. It should use sheep-nickname of the sheep's
     metasheep.
**** TODO #'print-orphaned-sheep with second-lowest priority
     For sheep that have no parents, but are otherwise functional. Ditto wrt the
     metasheep nickname.
**** TODO #'print-sheep with highest priority
     A method, user-extensible and awesome.
*** TODO #'std-remove-parent should make sure that the hierarchy list is still valid.
*** TODO Once bootstrapped, update WITH-SHEEP-HIERARCHY to use SPAWN
*** TODO Write VALIDATE-HIERARCHY-LIST
* DONE 2.2
** DONE [#A] Fix #'(setf property-value) Bug
   When a call to #'(setf property-value) requires a new direct property object
   to be allocated, it doesn't get initialized properly.
   Sample code that invokes this bug:
   CL-USER> (defproto =foo= ()
              ((var "foobar")))
      #<Sheep AKA: =FOO= #x30004145841D>
   CL-USER> (defproto =bar= (=foo=)
              ())
      #<Sheep AKA: =BAR= #x30004146B76D>
   CL-USER> (setf (var =bar=) "barfoo")
      "barfoo"
** DONE Property Metaobject
*** DONE Implement property-spec-based dispatch for property-related stuff.
    PROPERTY-VALUE should call a message that dispatches based on the metaobject
    of the property being looked up. Important for PSheep!
*** TODO Write full unit tests to make sure it all works as expected.
** DONE Make defproto behave like 1.0's defsheep.
** DONE Start writing unit-tests for Message/reply stuff
* DONE 2.1
** DONE Replace find-proto with proto
   Let's try and shorten this and see if it helps.
** DONE Keep a close eye on #@ -- do I really need it?
   Reader macros are nasty. Maybe I should've thought more before tossing it in there.
   #@ is gone.
** DONE More helpful errors
   Try and catch errors a little earlier, report more useful stuff. Is there a way
   for reply-dispatch errors to be more informative?
   Update: I think this is better?...
* DONE 2.0
  Sheeple gets serious -- and more useful. The version jumps because this will completely
  break backwards compatibility with all previous sheeple code.
** DONE New interface
*** DONE CLONE -> function
    CLONE should be turned into a very simple function: (clone &rest sheep)
*** DONE CLONE* -> DEFCLONE
    What is currently CLONE should be renamed to DEFCLONE. More involved cloning capabilities
    are still nice.
*** DONE DEFSHEEP->DEFPROTO
    Time to get a bit more serious. DEFPROTO is a much clearer name.
*** DONE Mitosis->copy-sheep
    Also, get it working properly.
*** DONE defbuzzword -> defmessage
    Rename this thing. It really doesn't have to be silly.
*** DONE defmessage -> defreply
    I think I could get used to this naming scheme instead.
*** DONE Fleeced Wolf -> Boxed built-in
*** DONE =white-fang= -> boxed-object
*** DONE Fleecing -> Autoboxing
** DONE Make psheep easier to implement
*** DONE The order in which a sheep is built needs to be planned out more carefully.
    UPDATE: I think this is just about ready. Should probably think about this for a while first,
    and then it'll be done.
    UPDATE: I think this is good enough. It's straightforward.
** DONE More cleanup and convenience
*** DONE Get rid of add-on-write. Require add-property.
    Add-on-write seems like a quick interface, but it's a bit obnoxious to deal with.
    Not only does it create a risk for some serious hard-to-track bugs, but it makes
    it trickier to allocate space for properties when using the MOP.
*** DONE Shallow-copy/deep-copy should not be options.
    These are stupid, and they clutter up the interface. Never used them, never had to.
    Deep-copy could be its own function, under a different name, but it's easy enough
    to implement externally -- I'll see if it's ever used by anyone.
*** DONE Completely remove cloneforms
*** DONE Make nicknames generic properties?
    Or something similar. Would be nice to have some pointer as to what type an object is.
    UPDATE: Not for this version. This can be done later.
*** DONE Put prototypes into their own namespace
    CL is a lisp-n. Classes, functions, variables, are all stored in different namespaces.
    Thus, even though there isn't much of a difference between regular objects and prototypes,
    prototypes defined with defproto should be dumped into their own namespace, and the =foo=
    naming scheme should be dropped as a convention.
    Implementing this is simply a matter of having a hash-table of symbol->object mappings
    (the same way find-class works). The Sheeple counterpart of find-class would be find-proto.
    UPDATE: This is mostly done. Just gotta make sure everything works properly.
*** DONE Fix reinitialize-sheep
    This should be modeled more after reinitialize-instance. i.e. it should be specified
    that its function is to update the parents and direct property values of its sheep argument.
    UPDATE: A better definition is "resets the sheep's parents with a list of new parents, and
    wipes out all its direct properties from the map."
*** DONE Implement something like Io's slotSummary
    This is really important! :-o
    UPDATE: direct-property-summary and property-summary should do the trick for now :)
    UPDATE: It actually works now. And it's fucking sexy.
*** DONE Seriously fucking clean up the message/reply thing
    Holy shit this whole thing is a huge mess. Maybe with
    some moving around, organizing, and renaming it'll look
    a little cleaner, but holy shit no wonder it breaks all
    the fucking time
    Update: I guess it's okay for now...
** DONE Sheeple is horribly broken -- fix it
   At this point, it's probably a better idea to go over all of sheeple again, bit by bit,
   and reimplement things as necessary. Try to clean up the interface and all that.
   Dispatch is completely broken, but it's probably due to reply definition. It might also
   have been caused by all the damn renaming I did all over the place. I really never learn
   my lesson.
   Ah well, there goes the rest of my week.
   UPDATE: Woo, it seems to work now!
** DONE Tests
   All these changes should have a completely new set of unit tests written for them.
   While I'm at it, this could be an opportunity to improve the structure of the tests,
   and improve overall test coverage. They're broken right now, anyways. Ah well :\
   Do not tag and release 2.0 until all tests are written, and pass.
   Update: screw it. I'll write message-related tests later.
*** DONE Sheeple.lisp
*** DONE properties.lisp
*** DONE protos.lisp
*** DONE builtins.lisp
** DONE Fix bugs
   The tests should oust a bunch of bugs. Fix them.
** DONE Rewrite documentation
** DONE Rewrite examples
** DONE Figure out init-sheep
   Where should it go? What should it do?
   It would be nice if it was called -after- properties were
   added when using defclone/defproto. Or maybe the standard
   reply should add property-definitions handed to spawn-sheep
   by defclone/defproto?
   Init-sheep is fine. It should be noted that init-sheep runs after parents
   are added, but before any direct properties are set.
* DONE 1.1
** DONE Rewrite sheeple using CLOS
** DONE Expose enough of a MOP for psheep to be able to do its thing.
** DONE No-arg buzzwords don't work. Fix it.
** DONE Document new MOP features
* DONE 1.0.1
** DONE Allow individual message documentation
** DONE Add CLONE/CLONE*/DEFSHEEP :documentation option
** DONE Write a small sample application
   This will really help me iron out any last details in the API that are important enough to have
   there before 1.0 ships. Plus, it's silly to release shit without even trying it...
   I thought it would be a good idea to convert yashmup, but the current approach of simply renaming
   everything doesn't work, because of the behavior of prototypes, and the setup I had for classes
   (which was pretty awful).
   What I should do instead is start a different project, based on yashmup, but coded in sheeple
   from the bottom up.
   UPDATE: There's been lots of progress since I started working on UID. Tagging this as done (for now)
** DONE Document code
    Note: I can use stuff from the user's guide for this, but it's important.
    UPDATE: it's documented enough (for now).
** DONE Fix the fucking :around message dispatch bullshit.
   THERE. DONE. FUCK.
** DONE Dispatching messages with things like strings or numbers creates a new wolf every time.
   This is pretty terrible. I should at least fix stuff so that fleeced wolves are created only
   when necessary.
   Note: Fleeced wolves only need to exist if there are messages defined on them. Thus, if a message
   is dispatched, it first checks if there is a wolf created for that built-in type. If not, it
   can just find its built-in 'parent'.
   This is such a horrible source of memory leakage.
* DONE 1.0
** DONE Complete documentation
*** DONE Write proper user guide
*** DONE Update guide
** DONE Fix any bugs unit tests come up with
*** DONE Oops -- CLONE should check that defining an accessor first, then passing it NIL is also an error
*** DONE Undefmessage really isn't doing what it's supposed to.
    All tests pass, too!
** DONE Finalize API
   No (significant) changes allowed to API until 2.0, after this release.
*** DONE Do I want to make CLONE work more like defclass*?
    That might be good. It would not be incompatible with older versions of Sheeple, either.
*** DONE Deprecate :manipulator?
    I should deprecate :manipulator in favor of :accessor, since with-accessors will work on both
    CLOS and Sheeple. :accessor is much nicer... I'll remain compatible for now.
*** DONE Go through src/packages.lisp and figure out how much I actually need right now.
*** DONE Should I shut off access to stuff like undefbuzzword/undefmessage?
    Undefbuzzword definitely gone, undefmessage staying for now.
*** DONE (De-)(Re-)implement property objects, allow them to be lockable
    Actually, I think I should get rid of property-objects and make it just so an entire sheep can
    be locked at once.
    UPDATE: All set. Sheeple are now locked as a whole.
*** DONE Forgot MITOSIS >_>
    lol, no I didn't -- but it needed to be fixed anyway
*** DONE Is a :copy-on-clone option for individual properties better than :cloneform for most purposes?
    No.
*** DONE Need a way to list all messages that a sheep can participate in
    LOLOLOLO I ALREADY DID THIS XD XD XD
*** DONE Finalize everything when all else is done.
** DONE Fucking get rid of all these optimization declarations.
   One of these days I'll learn to heed my own fucking advice
* DONE 0.9
** DONE More optimization
   The goal here is to have manipulator dispatch be at a maximum 2x slower than property-value. If I
   can get it as fast as direct property-access, even better, but this shit can go so much faster
   without too much magic.
   Update: currently down to just under 10x slower for single dispatch vs direct property access
   Update: make that 5x slower. ;)
   Update: Sped up (setf property-value) a bit. I'm going to have to make a decision about what
   needs to be faster here -- perhaps I'll find out once I write some apps.
   Update: Caching property-owners was silly, and became incredibly expensive
   Update: Will stop optimizing after manipulators are optimized to an acceptable speed.
   Update: 5x really isn't that bad. I'm going to keep it for now.
** DONE Convert CHANGELOG to .org
** DONE Redefining buzzwords
   It would be really nice if buzzword-redefinition followed the same rules as CLOS
   Update: Good enough for now. It warns about shit.
* DONE 0.8
** DONE Optimize the shit out of message dispatch
   It's pretty fast right now, but nothing compared to PCL.
   I should read through the Slate paper again and see if I can implement any of their
   suggested optimizations.
   Additionally, I found a paper that talks about how PCL's caching works. I think I can
   implement something similar in sheeple, which would then make message dispatch absurdly fast.
   One word: MEMOIZATION. Do it.
   Memoization done, but profiling shows that there's other stuff in the way (such as the
   numerous calls to remove-if-not -during- dispatch time. Shit.
   As far as this remove-if-not, etc stuff goes -- I think I can figure out some fancy
   message-list caching system. The problem is that make-message-lambda might get confused, and
   I want to avoid changing stuff outside of message-dispatch.lisp as much as possible.
   There will be a time in the future when heavy-optimization and code-uglying will be appropriate.
   But for now, while the system is still being designed, it's best to keep things clean and
   flexible (and slow...).
   UPDATE: New caching system has made shit run hella-fast. According to sb-sprof, the next step
   would be to have a nicer hashing scheme, since using a list and using equal to fetch stuff from
   a hash table isn't really very speedy. For now, though, this will do! :) (haven't really tested
   this too much, though. Hm.)
** DONE Fix lambda-list keyword things
* DONE 0.7
** DONE Make initialize-instance a buzzword so :after messages can be defined
   both initialize-instance and reinitialize-instance are regular buzzwords now.
** DONE Have buzzwords accept &keywords in lambda lists, and maintain congruence as per CLOS
   This seemed to be working, but I have to put &allow-other-keys in all methods in order for it
   to work, which is sub-optimal. This can be fixed, and I should do it by 0.8
   UPDATE: Fix'd in make-message-lambda :)
* DONE 0.6
** DONE Write a replace-sheep function
  it should swap a sheep's properties/contents with a new 'definition',
  while maintaining identity.
** DONE Wrap replace-sheep with a DEFSHEEP macro.
** DONE Optimize the shit out of property-access
  Done for now -- it's only slightly slower than PCL right now
** DONE Work out the whole conditions thing, and what they print out.
   Put them all in conditions.lisp?
* DONE 0.5
** DONE Get all pre-0.6 done by 0.5
